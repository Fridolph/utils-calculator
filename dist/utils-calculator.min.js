//#region rolldown:runtime
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function() {
	return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

//#endregion

//#region node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.js
var require_decimal = /* @__PURE__ */ __commonJS({ "node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.js": ((exports, module) => {
	(function(globalScope) {
		/*!
		*  decimal.js v10.6.0
		*  An arbitrary-precision Decimal type for JavaScript.
		*  https://github.com/MikeMcl/decimal.js
		*  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
		*  MIT Licence
		*/
		var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
			precision: 20,
			rounding: 4,
			modulo: 1,
			toExpNeg: -7,
			toExpPos: 21,
			minE: -EXP_LIMIT,
			maxE: EXP_LIMIT,
			crypto: false
		}, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
		P.absoluteValue = P.abs = function() {
			var x = new this.constructor(this);
			if (x.s < 0) x.s = 1;
			return finalise(x);
		};
		P.ceil = function() {
			return finalise(new this.constructor(this), this.e + 1, 2);
		};
		P.clampedTo = P.clamp = function(min$1, max$1) {
			var k, x = this, Ctor = x.constructor;
			min$1 = new Ctor(min$1);
			max$1 = new Ctor(max$1);
			if (!min$1.s || !max$1.s) return new Ctor(NaN);
			if (min$1.gt(max$1)) throw Error(invalidArgument + max$1);
			k = x.cmp(min$1);
			return k < 0 ? min$1 : x.cmp(max$1) > 0 ? max$1 : new Ctor(x);
		};
		P.comparedTo = P.cmp = function(y) {
			var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
			if (!xd || !yd) return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
			if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
			if (xs !== ys) return xs;
			if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
			xdL = xd.length;
			ydL = yd.length;
			for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
			return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
		};
		P.cosine = P.cos = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (!x.d) return new Ctor(NaN);
			if (!x.d[0]) return new Ctor(1);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
			Ctor.rounding = 1;
			x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
		};
		P.cubeRoot = P.cbrt = function() {
			var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
			if (!x.isFinite() || x.isZero()) return new Ctor(x);
			external = false;
			s = x.s * mathpow(x.s * x, 1 / 3);
			if (!s || Math.abs(s) == Infinity) {
				n = digitsToString(x.d);
				e = x.e;
				if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
				s = mathpow(n, 1 / 3);
				e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
				if (s == Infinity) n = "5e" + e;
				else {
					n = s.toExponential();
					n = n.slice(0, n.indexOf("e") + 1) + e;
				}
				r = new Ctor(n);
				r.s = x.s;
			} else r = new Ctor(s.toString());
			sd = (e = Ctor.precision) + 3;
			for (;;) {
				t = r;
				t3 = t.times(t).times(t);
				t3plusx = t3.plus(x);
				r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
				if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
					n = n.slice(sd - 3, sd + 1);
					if (n == "9999" || !rep && n == "4999") {
						if (!rep) {
							finalise(t, e + 1, 0);
							if (t.times(t).times(t).eq(x)) {
								r = t;
								break;
							}
						}
						sd += 4;
						rep = 1;
					} else {
						if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
							finalise(r, e + 1, 1);
							m = !r.times(r).times(r).eq(x);
						}
						break;
					}
				}
			}
			external = true;
			return finalise(r, e, Ctor.rounding, m);
		};
		P.decimalPlaces = P.dp = function() {
			var w, d = this.d, n = NaN;
			if (d) {
				w = d.length - 1;
				n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
				w = d[w];
				if (w) for (; w % 10 == 0; w /= 10) n--;
				if (n < 0) n = 0;
			}
			return n;
		};
		P.dividedBy = P.div = function(y) {
			return divide(this, new this.constructor(y));
		};
		P.dividedToIntegerBy = P.divToInt = function(y) {
			var x = this, Ctor = x.constructor;
			return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
		};
		P.equals = P.eq = function(y) {
			return this.cmp(y) === 0;
		};
		P.floor = function() {
			return finalise(new this.constructor(this), this.e + 1, 3);
		};
		P.greaterThan = P.gt = function(y) {
			return this.cmp(y) > 0;
		};
		P.greaterThanOrEqualTo = P.gte = function(y) {
			var k = this.cmp(y);
			return k == 1 || k === 0;
		};
		P.hyperbolicCosine = P.cosh = function() {
			var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
			if (!x.isFinite()) return new Ctor(x.s ? Infinity : NaN);
			if (x.isZero()) return one;
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
			Ctor.rounding = 1;
			len = x.d.length;
			if (len < 32) {
				k = Math.ceil(len / 3);
				n = (1 / tinyPow(4, k)).toString();
			} else {
				k = 16;
				n = "2.3283064365386962890625e-10";
			}
			x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
			var cosh2_x, i = k, d8 = new Ctor(8);
			for (; i--;) {
				cosh2_x = x.times(x);
				x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
			}
			return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
		};
		P.hyperbolicSine = P.sinh = function() {
			var k, pr, rm, len, x = this, Ctor = x.constructor;
			if (!x.isFinite() || x.isZero()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
			Ctor.rounding = 1;
			len = x.d.length;
			if (len < 3) x = taylorSeries(Ctor, 2, x, x, true);
			else {
				k = 1.4 * Math.sqrt(len);
				k = k > 16 ? 16 : k | 0;
				x = x.times(1 / tinyPow(5, k));
				x = taylorSeries(Ctor, 2, x, x, true);
				var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
				for (; k--;) {
					sinh2_x = x.times(x);
					x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
				}
			}
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return finalise(x, pr, rm, true);
		};
		P.hyperbolicTangent = P.tanh = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (!x.isFinite()) return new Ctor(x.s);
			if (x.isZero()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + 7;
			Ctor.rounding = 1;
			return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
		};
		P.inverseCosine = P.acos = function() {
			var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
			if (k !== -1) return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
			if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(.5);
			Ctor.precision = pr + 6;
			Ctor.rounding = 1;
			x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return x.times(2);
		};
		P.inverseHyperbolicCosine = P.acosh = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
			if (!x.isFinite()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
			Ctor.rounding = 1;
			external = false;
			x = x.times(x).minus(1).sqrt().plus(x);
			external = true;
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return x.ln();
		};
		P.inverseHyperbolicSine = P.asinh = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (!x.isFinite() || x.isZero()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
			Ctor.rounding = 1;
			external = false;
			x = x.times(x).plus(1).sqrt().plus(x);
			external = true;
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return x.ln();
		};
		P.inverseHyperbolicTangent = P.atanh = function() {
			var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
			if (!x.isFinite()) return new Ctor(NaN);
			if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			xsd = x.sd();
			if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
			Ctor.precision = wpr = xsd - x.e;
			x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
			Ctor.precision = pr + 4;
			Ctor.rounding = 1;
			x = x.ln();
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return x.times(.5);
		};
		P.inverseSine = P.asin = function() {
			var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
			if (x.isZero()) return new Ctor(x);
			k = x.abs().cmp(1);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			if (k !== -1) {
				if (k === 0) {
					halfPi = getPi(Ctor, pr + 4, rm).times(.5);
					halfPi.s = x.s;
					return halfPi;
				}
				return new Ctor(NaN);
			}
			Ctor.precision = pr + 6;
			Ctor.rounding = 1;
			x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return x.times(2);
		};
		P.inverseTangent = P.atan = function() {
			var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
			if (!x.isFinite()) {
				if (!x.s) return new Ctor(NaN);
				if (pr + 4 <= PI_PRECISION) {
					r = getPi(Ctor, pr + 4, rm).times(.5);
					r.s = x.s;
					return r;
				}
			} else if (x.isZero()) return new Ctor(x);
			else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
				r = getPi(Ctor, pr + 4, rm).times(.25);
				r.s = x.s;
				return r;
			}
			Ctor.precision = wpr = pr + 10;
			Ctor.rounding = 1;
			k = Math.min(28, wpr / LOG_BASE + 2 | 0);
			for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
			external = false;
			j = Math.ceil(wpr / LOG_BASE);
			n = 1;
			x2 = x.times(x);
			r = new Ctor(x);
			px = x;
			for (; i !== -1;) {
				px = px.times(x2);
				t = r.minus(px.div(n += 2));
				px = px.times(x2);
				r = t.plus(px.div(n += 2));
				if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
			}
			if (k) r = r.times(2 << k - 1);
			external = true;
			return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
		};
		P.isFinite = function() {
			return !!this.d;
		};
		P.isInteger = P.isInt = function() {
			return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
		};
		P.isNaN = function() {
			return !this.s;
		};
		P.isNegative = P.isNeg = function() {
			return this.s < 0;
		};
		P.isPositive = P.isPos = function() {
			return this.s > 0;
		};
		P.isZero = function() {
			return !!this.d && this.d[0] === 0;
		};
		P.lessThan = P.lt = function(y) {
			return this.cmp(y) < 0;
		};
		P.lessThanOrEqualTo = P.lte = function(y) {
			return this.cmp(y) < 1;
		};
		P.logarithm = P.log = function(base) {
			var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
			if (base == null) {
				base = new Ctor(10);
				isBase10 = true;
			} else {
				base = new Ctor(base);
				d = base.d;
				if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
				isBase10 = base.eq(10);
			}
			d = arg.d;
			if (arg.s < 0 || !d || !d[0] || arg.eq(1)) return new Ctor(d && !d[0] ? -Infinity : arg.s != 1 ? NaN : d ? 0 : Infinity);
			if (isBase10) if (d.length > 1) inf = true;
			else {
				for (k = d[0]; k % 10 === 0;) k /= 10;
				inf = k !== 1;
			}
			external = false;
			sd = pr + guard;
			num = naturalLogarithm(arg, sd);
			denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
			r = divide(num, denominator, sd, 1);
			if (checkRoundingDigits(r.d, k = pr, rm)) do {
				sd += 10;
				num = naturalLogarithm(arg, sd);
				denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
				r = divide(num, denominator, sd, 1);
				if (!inf) {
					if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 0x5af3107a4000) r = finalise(r, pr + 1, 0);
					break;
				}
			} while (checkRoundingDigits(r.d, k += 10, rm));
			external = true;
			return finalise(r, pr, rm);
		};
		P.minus = P.sub = function(y) {
			var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
			y = new Ctor(y);
			if (!x.d || !y.d) {
				if (!x.s || !y.s) y = new Ctor(NaN);
				else if (x.d) y.s = -y.s;
				else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
				return y;
			}
			if (x.s != y.s) {
				y.s = -y.s;
				return x.plus(y);
			}
			xd = x.d;
			yd = y.d;
			pr = Ctor.precision;
			rm = Ctor.rounding;
			if (!xd[0] || !yd[0]) {
				if (yd[0]) y.s = -y.s;
				else if (xd[0]) y = new Ctor(x);
				else return new Ctor(rm === 3 ? -0 : 0);
				return external ? finalise(y, pr, rm) : y;
			}
			e = mathfloor(y.e / LOG_BASE);
			xe = mathfloor(x.e / LOG_BASE);
			xd = xd.slice();
			k = xe - e;
			if (k) {
				xLTy = k < 0;
				if (xLTy) {
					d = xd;
					k = -k;
					len = yd.length;
				} else {
					d = yd;
					e = xe;
					len = xd.length;
				}
				i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
				if (k > i) {
					k = i;
					d.length = 1;
				}
				d.reverse();
				for (i = k; i--;) d.push(0);
				d.reverse();
			} else {
				i = xd.length;
				len = yd.length;
				xLTy = i < len;
				if (xLTy) len = i;
				for (i = 0; i < len; i++) if (xd[i] != yd[i]) {
					xLTy = xd[i] < yd[i];
					break;
				}
				k = 0;
			}
			if (xLTy) {
				d = xd;
				xd = yd;
				yd = d;
				y.s = -y.s;
			}
			len = xd.length;
			for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
			for (i = yd.length; i > k;) {
				if (xd[--i] < yd[i]) {
					for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
					--xd[j];
					xd[i] += BASE;
				}
				xd[i] -= yd[i];
			}
			for (; xd[--len] === 0;) xd.pop();
			for (; xd[0] === 0; xd.shift()) --e;
			if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
			y.d = xd;
			y.e = getBase10Exponent(xd, e);
			return external ? finalise(y, pr, rm) : y;
		};
		P.modulo = P.mod = function(y) {
			var q, x = this, Ctor = x.constructor;
			y = new Ctor(y);
			if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
			if (!y.d || x.d && !x.d[0]) return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
			external = false;
			if (Ctor.modulo == 9) {
				q = divide(x, y.abs(), 0, 3, 1);
				q.s *= y.s;
			} else q = divide(x, y, 0, Ctor.modulo, 1);
			q = q.times(y);
			external = true;
			return x.minus(q);
		};
		P.naturalExponential = P.exp = function() {
			return naturalExponential(this);
		};
		P.naturalLogarithm = P.ln = function() {
			return naturalLogarithm(this);
		};
		P.negated = P.neg = function() {
			var x = new this.constructor(this);
			x.s = -x.s;
			return finalise(x);
		};
		P.plus = P.add = function(y) {
			var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
			y = new Ctor(y);
			if (!x.d || !y.d) {
				if (!x.s || !y.s) y = new Ctor(NaN);
				else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
				return y;
			}
			if (x.s != y.s) {
				y.s = -y.s;
				return x.minus(y);
			}
			xd = x.d;
			yd = y.d;
			pr = Ctor.precision;
			rm = Ctor.rounding;
			if (!xd[0] || !yd[0]) {
				if (!yd[0]) y = new Ctor(x);
				return external ? finalise(y, pr, rm) : y;
			}
			k = mathfloor(x.e / LOG_BASE);
			e = mathfloor(y.e / LOG_BASE);
			xd = xd.slice();
			i = k - e;
			if (i) {
				if (i < 0) {
					d = xd;
					i = -i;
					len = yd.length;
				} else {
					d = yd;
					e = k;
					len = xd.length;
				}
				k = Math.ceil(pr / LOG_BASE);
				len = k > len ? k + 1 : len + 1;
				if (i > len) {
					i = len;
					d.length = 1;
				}
				d.reverse();
				for (; i--;) d.push(0);
				d.reverse();
			}
			len = xd.length;
			i = yd.length;
			if (len - i < 0) {
				i = len;
				d = yd;
				yd = xd;
				xd = d;
			}
			for (carry = 0; i;) {
				carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
				xd[i] %= BASE;
			}
			if (carry) {
				xd.unshift(carry);
				++e;
			}
			for (len = xd.length; xd[--len] == 0;) xd.pop();
			y.d = xd;
			y.e = getBase10Exponent(xd, e);
			return external ? finalise(y, pr, rm) : y;
		};
		P.precision = P.sd = function(z) {
			var k, x = this;
			if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
			if (x.d) {
				k = getPrecision(x.d);
				if (z && x.e + 1 > k) k = x.e + 1;
			} else k = NaN;
			return k;
		};
		P.round = function() {
			var x = this, Ctor = x.constructor;
			return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
		};
		P.sine = P.sin = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (!x.isFinite()) return new Ctor(NaN);
			if (x.isZero()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
			Ctor.rounding = 1;
			x = sine(Ctor, toLessThanHalfPi(Ctor, x));
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
		};
		P.squareRoot = P.sqrt = function() {
			var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
			if (s !== 1 || !d || !d[0]) return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : Infinity);
			external = false;
			s = Math.sqrt(+x);
			if (s == 0 || s == Infinity) {
				n = digitsToString(d);
				if ((n.length + e) % 2 == 0) n += "0";
				s = Math.sqrt(n);
				e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
				if (s == Infinity) n = "5e" + e;
				else {
					n = s.toExponential();
					n = n.slice(0, n.indexOf("e") + 1) + e;
				}
				r = new Ctor(n);
			} else r = new Ctor(s.toString());
			sd = (e = Ctor.precision) + 3;
			for (;;) {
				t = r;
				r = t.plus(divide(x, t, sd + 2, 1)).times(.5);
				if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
					n = n.slice(sd - 3, sd + 1);
					if (n == "9999" || !rep && n == "4999") {
						if (!rep) {
							finalise(t, e + 1, 0);
							if (t.times(t).eq(x)) {
								r = t;
								break;
							}
						}
						sd += 4;
						rep = 1;
					} else {
						if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
							finalise(r, e + 1, 1);
							m = !r.times(r).eq(x);
						}
						break;
					}
				}
			}
			external = true;
			return finalise(r, e, Ctor.rounding, m);
		};
		P.tangent = P.tan = function() {
			var pr, rm, x = this, Ctor = x.constructor;
			if (!x.isFinite()) return new Ctor(NaN);
			if (x.isZero()) return new Ctor(x);
			pr = Ctor.precision;
			rm = Ctor.rounding;
			Ctor.precision = pr + 10;
			Ctor.rounding = 1;
			x = x.sin();
			x.s = 1;
			x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
			Ctor.precision = pr;
			Ctor.rounding = rm;
			return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
		};
		P.times = P.mul = function(y) {
			var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
			y.s *= x.s;
			if (!xd || !xd[0] || !yd || !yd[0]) return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
			e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
			xdL = xd.length;
			ydL = yd.length;
			if (xdL < ydL) {
				r = xd;
				xd = yd;
				yd = r;
				rL = xdL;
				xdL = ydL;
				ydL = rL;
			}
			r = [];
			rL = xdL + ydL;
			for (i = rL; i--;) r.push(0);
			for (i = ydL; --i >= 0;) {
				carry = 0;
				for (k = xdL + i; k > i;) {
					t = r[k] + yd[i] * xd[k - i - 1] + carry;
					r[k--] = t % BASE | 0;
					carry = t / BASE | 0;
				}
				r[k] = (r[k] + carry) % BASE | 0;
			}
			for (; !r[--rL];) r.pop();
			if (carry) ++e;
			else r.shift();
			y.d = r;
			y.e = getBase10Exponent(r, e);
			return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
		};
		P.toBinary = function(sd, rm) {
			return toStringBinary(this, 2, sd, rm);
		};
		P.toDecimalPlaces = P.toDP = function(dp, rm) {
			var x = this, Ctor = x.constructor;
			x = new Ctor(x);
			if (dp === void 0) return x;
			checkInt32(dp, 0, MAX_DIGITS);
			if (rm === void 0) rm = Ctor.rounding;
			else checkInt32(rm, 0, 8);
			return finalise(x, dp + x.e + 1, rm);
		};
		P.toExponential = function(dp, rm) {
			var str, x = this, Ctor = x.constructor;
			if (dp === void 0) str = finiteToString(x, true);
			else {
				checkInt32(dp, 0, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x = finalise(new Ctor(x), dp + 1, rm);
				str = finiteToString(x, true, dp + 1);
			}
			return x.isNeg() && !x.isZero() ? "-" + str : str;
		};
		P.toFixed = function(dp, rm) {
			var str, y, x = this, Ctor = x.constructor;
			if (dp === void 0) str = finiteToString(x);
			else {
				checkInt32(dp, 0, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				y = finalise(new Ctor(x), dp + x.e + 1, rm);
				str = finiteToString(y, false, dp + y.e + 1);
			}
			return x.isNeg() && !x.isZero() ? "-" + str : str;
		};
		P.toFraction = function(maxD) {
			var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
			if (!xd) return new Ctor(x);
			n1 = d0 = new Ctor(1);
			d1 = n0 = new Ctor(0);
			d = new Ctor(d1);
			e = d.e = getPrecision(xd) - x.e - 1;
			k = e % LOG_BASE;
			d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
			if (maxD == null) maxD = e > 0 ? d : n1;
			else {
				n = new Ctor(maxD);
				if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
				maxD = n.gt(d) ? e > 0 ? d : n1 : n;
			}
			external = false;
			n = new Ctor(digitsToString(xd));
			pr = Ctor.precision;
			Ctor.precision = e = xd.length * LOG_BASE * 2;
			for (;;) {
				q = divide(n, d, 0, 1, 1);
				d2 = d0.plus(q.times(d1));
				if (d2.cmp(maxD) == 1) break;
				d0 = d1;
				d1 = d2;
				d2 = n1;
				n1 = n0.plus(q.times(d2));
				n0 = d2;
				d2 = d;
				d = n.minus(q.times(d2));
				n = d2;
			}
			d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
			n0 = n0.plus(d2.times(n1));
			d0 = d0.plus(d2.times(d1));
			n0.s = n1.s = x.s;
			r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
			Ctor.precision = pr;
			external = true;
			return r;
		};
		P.toHexadecimal = P.toHex = function(sd, rm) {
			return toStringBinary(this, 16, sd, rm);
		};
		P.toNearest = function(y, rm) {
			var x = this, Ctor = x.constructor;
			x = new Ctor(x);
			if (y == null) {
				if (!x.d) return x;
				y = new Ctor(1);
				rm = Ctor.rounding;
			} else {
				y = new Ctor(y);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				if (!x.d) return y.s ? x : y;
				if (!y.d) {
					if (y.s) y.s = x.s;
					return y;
				}
			}
			if (y.d[0]) {
				external = false;
				x = divide(x, y, 0, rm, 1).times(y);
				external = true;
				finalise(x);
			} else {
				y.s = x.s;
				x = y;
			}
			return x;
		};
		P.toNumber = function() {
			return +this;
		};
		P.toOctal = function(sd, rm) {
			return toStringBinary(this, 8, sd, rm);
		};
		P.toPower = P.pow = function(y) {
			var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
			if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
			x = new Ctor(x);
			if (x.eq(1)) return x;
			pr = Ctor.precision;
			rm = Ctor.rounding;
			if (y.eq(1)) return finalise(x, pr, rm);
			e = mathfloor(y.e / LOG_BASE);
			if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
				r = intPow(Ctor, x, k, pr);
				return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
			}
			s = x.s;
			if (s < 0) {
				if (e < y.d.length - 1) return new Ctor(NaN);
				if ((y.d[e] & 1) == 0) s = 1;
				if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
					x.s = s;
					return x;
				}
			}
			k = mathpow(+x, yn);
			e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
			if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
			external = false;
			Ctor.rounding = x.s = 1;
			k = Math.min(12, (e + "").length);
			r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
			if (r.d) {
				r = finalise(r, pr + 5, 1);
				if (checkRoundingDigits(r.d, pr, rm)) {
					e = pr + 10;
					r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
					if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 0x5af3107a4000) r = finalise(r, pr + 1, 0);
				}
			}
			r.s = s;
			external = true;
			Ctor.rounding = rm;
			return finalise(r, pr, rm);
		};
		P.toPrecision = function(sd, rm) {
			var str, x = this, Ctor = x.constructor;
			if (sd === void 0) str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
			else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
				x = finalise(new Ctor(x), sd, rm);
				str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
			}
			return x.isNeg() && !x.isZero() ? "-" + str : str;
		};
		P.toSignificantDigits = P.toSD = function(sd, rm) {
			var x = this, Ctor = x.constructor;
			if (sd === void 0) {
				sd = Ctor.precision;
				rm = Ctor.rounding;
			} else {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
			}
			return finalise(new Ctor(x), sd, rm);
		};
		P.toString = function() {
			var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
			return x.isNeg() && !x.isZero() ? "-" + str : str;
		};
		P.truncated = P.trunc = function() {
			return finalise(new this.constructor(this), this.e + 1, 1);
		};
		P.valueOf = P.toJSON = function() {
			var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
			return x.isNeg() ? "-" + str : str;
		};
		function digitsToString(d) {
			var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
			if (indexOfLastWord > 0) {
				str += w;
				for (i = 1; i < indexOfLastWord; i++) {
					ws = d[i] + "";
					k = LOG_BASE - ws.length;
					if (k) str += getZeroString(k);
					str += ws;
				}
				w = d[i];
				ws = w + "";
				k = LOG_BASE - ws.length;
				if (k) str += getZeroString(k);
			} else if (w === 0) return "0";
			for (; w % 10 === 0;) w /= 10;
			return str + w;
		}
		function checkInt32(i, min$1, max$1) {
			if (i !== ~~i || i < min$1 || i > max$1) throw Error(invalidArgument + i);
		}
		function checkRoundingDigits(d, i, rm, repeating) {
			var di, k, r, rd;
			for (k = d[0]; k >= 10; k /= 10) --i;
			if (--i < 0) {
				i += LOG_BASE;
				di = 0;
			} else {
				di = Math.ceil((i + 1) / LOG_BASE);
				i %= LOG_BASE;
			}
			k = mathpow(10, LOG_BASE - i);
			rd = d[di] % k | 0;
			if (repeating == null) if (i < 3) {
				if (i == 0) rd = rd / 100 | 0;
				else if (i == 1) rd = rd / 10 | 0;
				r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
			} else r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
			else if (i < 4) {
				if (i == 0) rd = rd / 1e3 | 0;
				else if (i == 1) rd = rd / 100 | 0;
				else if (i == 2) rd = rd / 10 | 0;
				r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
			} else r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
			return r;
		}
		function convertBase(str, baseIn, baseOut) {
			var j, arr = [0], arrL, i = 0, strL = str.length;
			for (; i < strL;) {
				for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
				arr[0] += NUMERALS.indexOf(str.charAt(i++));
				for (j = 0; j < arr.length; j++) if (arr[j] > baseOut - 1) {
					if (arr[j + 1] === void 0) arr[j + 1] = 0;
					arr[j + 1] += arr[j] / baseOut | 0;
					arr[j] %= baseOut;
				}
			}
			return arr.reverse();
		}
		function cosine(Ctor, x) {
			var k, len, y;
			if (x.isZero()) return x;
			len = x.d.length;
			if (len < 32) {
				k = Math.ceil(len / 3);
				y = (1 / tinyPow(4, k)).toString();
			} else {
				k = 16;
				y = "2.3283064365386962890625e-10";
			}
			Ctor.precision += k;
			x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
			for (var i = k; i--;) {
				var cos2x = x.times(x);
				x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
			}
			Ctor.precision -= k;
			return x;
		}
		var divide = (function() {
			function multiplyInteger(x, k, base) {
				var temp, carry = 0, i = x.length;
				for (x = x.slice(); i--;) {
					temp = x[i] * k + carry;
					x[i] = temp % base | 0;
					carry = temp / base | 0;
				}
				if (carry) x.unshift(carry);
				return x;
			}
			function compare(a, b, aL, bL) {
				var i, r;
				if (aL != bL) r = aL > bL ? 1 : -1;
				else for (i = r = 0; i < aL; i++) if (a[i] != b[i]) {
					r = a[i] > b[i] ? 1 : -1;
					break;
				}
				return r;
			}
			function subtract(a, b, aL, base) {
				var i = 0;
				for (; aL--;) {
					a[aL] -= i;
					i = a[aL] < b[aL] ? 1 : 0;
					a[aL] = i * base + a[aL] - b[aL];
				}
				for (; !a[0] && a.length > 1;) a.shift();
			}
			return function(x, y, pr, rm, dp, base) {
				var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign$1 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
				if (!xd || !xd[0] || !yd || !yd[0]) return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : xd && xd[0] == 0 || !yd ? sign$1 * 0 : sign$1 / 0);
				if (base) {
					logBase = 1;
					e = x.e - y.e;
				} else {
					base = BASE;
					logBase = LOG_BASE;
					e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
				}
				yL = yd.length;
				xL = xd.length;
				q = new Ctor(sign$1);
				qd = q.d = [];
				for (i = 0; yd[i] == (xd[i] || 0); i++);
				if (yd[i] > (xd[i] || 0)) e--;
				if (pr == null) {
					sd = pr = Ctor.precision;
					rm = Ctor.rounding;
				} else if (dp) sd = pr + (x.e - y.e) + 1;
				else sd = pr;
				if (sd < 0) {
					qd.push(1);
					more = true;
				} else {
					sd = sd / logBase + 2 | 0;
					i = 0;
					if (yL == 1) {
						k = 0;
						yd = yd[0];
						sd++;
						for (; (i < xL || k) && sd--; i++) {
							t = k * base + (xd[i] || 0);
							qd[i] = t / yd | 0;
							k = t % yd | 0;
						}
						more = k || i < xL;
					} else {
						k = base / (yd[0] + 1) | 0;
						if (k > 1) {
							yd = multiplyInteger(yd, k, base);
							xd = multiplyInteger(xd, k, base);
							yL = yd.length;
							xL = xd.length;
						}
						xi = yL;
						rem = xd.slice(0, yL);
						remL = rem.length;
						for (; remL < yL;) rem[remL++] = 0;
						yz = yd.slice();
						yz.unshift(0);
						yd0 = yd[0];
						if (yd[1] >= base / 2) ++yd0;
						do {
							k = 0;
							cmp = compare(yd, rem, yL, remL);
							if (cmp < 0) {
								rem0 = rem[0];
								if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
								k = rem0 / yd0 | 0;
								if (k > 1) {
									if (k >= base) k = base - 1;
									prod = multiplyInteger(yd, k, base);
									prodL = prod.length;
									remL = rem.length;
									cmp = compare(prod, rem, prodL, remL);
									if (cmp == 1) {
										k--;
										subtract(prod, yL < prodL ? yz : yd, prodL, base);
									}
								} else {
									if (k == 0) cmp = k = 1;
									prod = yd.slice();
								}
								prodL = prod.length;
								if (prodL < remL) prod.unshift(0);
								subtract(rem, prod, remL, base);
								if (cmp == -1) {
									remL = rem.length;
									cmp = compare(yd, rem, yL, remL);
									if (cmp < 1) {
										k++;
										subtract(rem, yL < remL ? yz : yd, remL, base);
									}
								}
								remL = rem.length;
							} else if (cmp === 0) {
								k++;
								rem = [0];
							}
							qd[i++] = k;
							if (cmp && rem[0]) rem[remL++] = xd[xi] || 0;
							else {
								rem = [xd[xi]];
								remL = 1;
							}
						} while ((xi++ < xL || rem[0] !== void 0) && sd--);
						more = rem[0] !== void 0;
					}
					if (!qd[0]) qd.shift();
				}
				if (logBase == 1) {
					q.e = e;
					inexact = more;
				} else {
					for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
					q.e = i + e * logBase - 1;
					finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
				}
				return q;
			};
		})();
		function finalise(x, sd, rm, isTruncated) {
			var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
			out: if (sd != null) {
				xd = x.d;
				if (!xd) return x;
				for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
				i = sd - digits;
				if (i < 0) {
					i += LOG_BASE;
					j = sd;
					w = xd[xdi = 0];
					rd = w / mathpow(10, digits - j - 1) % 10 | 0;
				} else {
					xdi = Math.ceil((i + 1) / LOG_BASE);
					k = xd.length;
					if (xdi >= k) if (isTruncated) {
						for (; k++ <= xdi;) xd.push(0);
						w = rd = 0;
						digits = 1;
						i %= LOG_BASE;
						j = i - LOG_BASE + 1;
					} else break out;
					else {
						w = k = xd[xdi];
						for (digits = 1; k >= 10; k /= 10) digits++;
						i %= LOG_BASE;
						j = i - LOG_BASE + digits;
						rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
					}
				}
				isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
				roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
				if (sd < 1 || !xd[0]) {
					xd.length = 0;
					if (roundUp) {
						sd -= x.e + 1;
						xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
						x.e = -sd || 0;
					} else xd[0] = x.e = 0;
					return x;
				}
				if (i == 0) {
					xd.length = xdi;
					k = 1;
					xdi--;
				} else {
					xd.length = xdi + 1;
					k = mathpow(10, LOG_BASE - i);
					xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
				}
				if (roundUp) for (;;) if (xdi == 0) {
					for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
					j = xd[0] += k;
					for (k = 1; j >= 10; j /= 10) k++;
					if (i != k) {
						x.e++;
						if (xd[0] == BASE) xd[0] = 1;
					}
					break;
				} else {
					xd[xdi] += k;
					if (xd[xdi] != BASE) break;
					xd[xdi--] = 0;
					k = 1;
				}
				for (i = xd.length; xd[--i] === 0;) xd.pop();
			}
			if (external) {
				if (x.e > Ctor.maxE) {
					x.d = null;
					x.e = NaN;
				} else if (x.e < Ctor.minE) {
					x.e = 0;
					x.d = [0];
				}
			}
			return x;
		}
		function finiteToString(x, isExp, sd) {
			if (!x.isFinite()) return nonFiniteToString(x);
			var k, e = x.e, str = digitsToString(x.d), len = str.length;
			if (isExp) {
				if (sd && (k = sd - len) > 0) str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
				else if (len > 1) str = str.charAt(0) + "." + str.slice(1);
				str = str + (x.e < 0 ? "e" : "e+") + x.e;
			} else if (e < 0) {
				str = "0." + getZeroString(-e - 1) + str;
				if (sd && (k = sd - len) > 0) str += getZeroString(k);
			} else if (e >= len) {
				str += getZeroString(e + 1 - len);
				if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
			} else {
				if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
				if (sd && (k = sd - len) > 0) {
					if (e + 1 === len) str += ".";
					str += getZeroString(k);
				}
			}
			return str;
		}
		function getBase10Exponent(digits, e) {
			var w = digits[0];
			for (e *= LOG_BASE; w >= 10; w /= 10) e++;
			return e;
		}
		function getLn10(Ctor, sd, pr) {
			if (sd > LN10_PRECISION) {
				external = true;
				if (pr) Ctor.precision = pr;
				throw Error(precisionLimitExceeded);
			}
			return finalise(new Ctor(LN10), sd, 1, true);
		}
		function getPi(Ctor, sd, rm) {
			if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
			return finalise(new Ctor(PI), sd, rm, true);
		}
		function getPrecision(digits) {
			var w = digits.length - 1, len = w * LOG_BASE + 1;
			w = digits[w];
			if (w) {
				for (; w % 10 == 0; w /= 10) len--;
				for (w = digits[0]; w >= 10; w /= 10) len++;
			}
			return len;
		}
		function getZeroString(k) {
			var zs = "";
			for (; k--;) zs += "0";
			return zs;
		}
		function intPow(Ctor, x, n, pr) {
			var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
			external = false;
			for (;;) {
				if (n % 2) {
					r = r.times(x);
					if (truncate(r.d, k)) isTruncated = true;
				}
				n = mathfloor(n / 2);
				if (n === 0) {
					n = r.d.length - 1;
					if (isTruncated && r.d[n] === 0) ++r.d[n];
					break;
				}
				x = x.times(x);
				truncate(x.d, k);
			}
			external = true;
			return r;
		}
		function isOdd(n) {
			return n.d[n.d.length - 1] & 1;
		}
		function maxOrMin(Ctor, args, n) {
			var k, y, x = new Ctor(args[0]), i = 0;
			for (; ++i < args.length;) {
				y = new Ctor(args[i]);
				if (!y.s) {
					x = y;
					break;
				}
				k = x.cmp(y);
				if (k === n || k === 0 && x.s === n) x = y;
			}
			return x;
		}
		function naturalExponential(x, sd) {
			var denominator, guard, j, pow$1, sum$1, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
			if (!x.d || !x.d[0] || x.e > 17) return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : Infinity : x.s ? x.s < 0 ? 0 : x : NaN);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			t = new Ctor(.03125);
			while (x.e > -2) {
				x = x.times(t);
				k += 5;
			}
			guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
			wpr += guard;
			denominator = pow$1 = sum$1 = new Ctor(1);
			Ctor.precision = wpr;
			for (;;) {
				pow$1 = finalise(pow$1.times(x), wpr, 1);
				denominator = denominator.times(++i);
				t = sum$1.plus(divide(pow$1, denominator, wpr, 1));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum$1.d).slice(0, wpr)) {
					j = k;
					while (j--) sum$1 = finalise(sum$1.times(sum$1), wpr, 1);
					if (sd == null) if (rep < 3 && checkRoundingDigits(sum$1.d, wpr - guard, rm, rep)) {
						Ctor.precision = wpr += 10;
						denominator = pow$1 = t = new Ctor(1);
						i = 0;
						rep++;
					} else return finalise(sum$1, Ctor.precision = pr, rm, external = true);
					else {
						Ctor.precision = pr;
						return sum$1;
					}
				}
				sum$1 = t;
			}
		}
		function naturalLogarithm(y, sd) {
			var c, c0, denominator, e, numerator, rep, sum$1, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
			if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) return new Ctor(xd && !xd[0] ? -Infinity : x.s != 1 ? NaN : xd ? 0 : x);
			if (sd == null) {
				external = false;
				wpr = pr;
			} else wpr = sd;
			Ctor.precision = wpr += guard;
			c = digitsToString(xd);
			c0 = c.charAt(0);
			if (Math.abs(e = x.e) < 0x5543df729c000) {
				while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
					x = x.times(y);
					c = digitsToString(x.d);
					c0 = c.charAt(0);
					n++;
				}
				e = x.e;
				if (c0 > 1) {
					x = new Ctor("0." + c);
					e++;
				} else x = new Ctor(c0 + "." + c.slice(1));
			} else {
				t = getLn10(Ctor, wpr + 2, pr).times(e + "");
				x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
				Ctor.precision = pr;
				return sd == null ? finalise(x, pr, rm, external = true) : x;
			}
			x1 = x;
			sum$1 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
			x2 = finalise(x.times(x), wpr, 1);
			denominator = 3;
			for (;;) {
				numerator = finalise(numerator.times(x2), wpr, 1);
				t = sum$1.plus(divide(numerator, new Ctor(denominator), wpr, 1));
				if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum$1.d).slice(0, wpr)) {
					sum$1 = sum$1.times(2);
					if (e !== 0) sum$1 = sum$1.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
					sum$1 = divide(sum$1, new Ctor(n), wpr, 1);
					if (sd == null) if (checkRoundingDigits(sum$1.d, wpr - guard, rm, rep)) {
						Ctor.precision = wpr += guard;
						t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
						x2 = finalise(x.times(x), wpr, 1);
						denominator = rep = 1;
					} else return finalise(sum$1, Ctor.precision = pr, rm, external = true);
					else {
						Ctor.precision = pr;
						return sum$1;
					}
				}
				sum$1 = t;
				denominator += 2;
			}
		}
		function nonFiniteToString(x) {
			return String(x.s * x.s / 0);
		}
		function parseDecimal(x, str) {
			var e, i, len;
			if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
			if ((i = str.search(/e/i)) > 0) {
				if (e < 0) e = i;
				e += +str.slice(i + 1);
				str = str.substring(0, i);
			} else if (e < 0) e = str.length;
			for (i = 0; str.charCodeAt(i) === 48; i++);
			for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
			str = str.slice(i, len);
			if (str) {
				len -= i;
				x.e = e = e - i - 1;
				x.d = [];
				i = (e + 1) % LOG_BASE;
				if (e < 0) i += LOG_BASE;
				if (i < len) {
					if (i) x.d.push(+str.slice(0, i));
					for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
					str = str.slice(i);
					i = LOG_BASE - str.length;
				} else i -= len;
				for (; i--;) str += "0";
				x.d.push(+str);
				if (external) {
					if (x.e > x.constructor.maxE) {
						x.d = null;
						x.e = NaN;
					} else if (x.e < x.constructor.minE) {
						x.e = 0;
						x.d = [0];
					}
				}
			} else {
				x.e = 0;
				x.d = [0];
			}
			return x;
		}
		function parseOther(x, str) {
			var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
			if (str.indexOf("_") > -1) {
				str = str.replace(/(\d)_(?=\d)/g, "$1");
				if (isDecimal.test(str)) return parseDecimal(x, str);
			} else if (str === "Infinity" || str === "NaN") {
				if (!+str) x.s = NaN;
				x.e = NaN;
				x.d = null;
				return x;
			}
			if (isHex.test(str)) {
				base = 16;
				str = str.toLowerCase();
			} else if (isBinary.test(str)) base = 2;
			else if (isOctal.test(str)) base = 8;
			else throw Error(invalidArgument + str);
			i = str.search(/p/i);
			if (i > 0) {
				p = +str.slice(i + 1);
				str = str.substring(2, i);
			} else str = str.slice(2);
			i = str.indexOf(".");
			isFloat = i >= 0;
			Ctor = x.constructor;
			if (isFloat) {
				str = str.replace(".", "");
				len = str.length;
				i = len - i;
				divisor = intPow(Ctor, new Ctor(base), i, i * 2);
			}
			xd = convertBase(str, base, BASE);
			xe = xd.length - 1;
			for (i = xe; xd[i] === 0; --i) xd.pop();
			if (i < 0) return new Ctor(x.s * 0);
			x.e = getBase10Exponent(xd, xe);
			x.d = xd;
			external = false;
			if (isFloat) x = divide(x, divisor, len * 4);
			if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
			external = true;
			return x;
		}
		function sine(Ctor, x) {
			var k, len = x.d.length;
			if (len < 3) return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
			k = 1.4 * Math.sqrt(len);
			k = k > 16 ? 16 : k | 0;
			x = x.times(1 / tinyPow(5, k));
			x = taylorSeries(Ctor, 2, x, x);
			var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
			for (; k--;) {
				sin2_x = x.times(x);
				x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
			}
			return x;
		}
		function taylorSeries(Ctor, n, x, y, isHyperbolic) {
			var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
			external = false;
			x2 = x.times(x);
			u = new Ctor(y);
			for (;;) {
				t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
				u = isHyperbolic ? y.plus(t) : y.minus(t);
				y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
				t = u.plus(y);
				if (t.d[k] !== void 0) {
					for (j = k; t.d[j] === u.d[j] && j--;);
					if (j == -1) break;
				}
				j = u;
				u = y;
				y = t;
				t = j;
				i++;
			}
			external = true;
			t.d.length = k + 1;
			return t;
		}
		function tinyPow(b, e) {
			var n = b;
			while (--e) n *= b;
			return n;
		}
		function toLessThanHalfPi(Ctor, x) {
			var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(.5);
			x = x.abs();
			if (x.lte(halfPi)) {
				quadrant = isNeg ? 4 : 1;
				return x;
			}
			t = x.divToInt(pi);
			if (t.isZero()) quadrant = isNeg ? 3 : 2;
			else {
				x = x.minus(t.times(pi));
				if (x.lte(halfPi)) {
					quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
					return x;
				}
				quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
			}
			return x.minus(pi).abs();
		}
		function toStringBinary(x, baseOut, sd, rm) {
			var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
			if (isExp) {
				checkInt32(sd, 1, MAX_DIGITS);
				if (rm === void 0) rm = Ctor.rounding;
				else checkInt32(rm, 0, 8);
			} else {
				sd = Ctor.precision;
				rm = Ctor.rounding;
			}
			if (!x.isFinite()) str = nonFiniteToString(x);
			else {
				str = finiteToString(x);
				i = str.indexOf(".");
				if (isExp) {
					base = 2;
					if (baseOut == 16) sd = sd * 4 - 3;
					else if (baseOut == 8) sd = sd * 3 - 2;
				} else base = baseOut;
				if (i >= 0) {
					str = str.replace(".", "");
					y = new Ctor(1);
					y.e = str.length - i;
					y.d = convertBase(finiteToString(y), 10, base);
					y.e = y.d.length;
				}
				xd = convertBase(str, 10, base);
				e = len = xd.length;
				for (; xd[--len] == 0;) xd.pop();
				if (!xd[0]) str = isExp ? "0p+0" : "0";
				else {
					if (i < 0) e--;
					else {
						x = new Ctor(x);
						x.d = xd;
						x.e = e;
						x = divide(x, y, sd, rm, 0, base);
						xd = x.d;
						e = x.e;
						roundUp = inexact;
					}
					i = xd[sd];
					k = base / 2;
					roundUp = roundUp || xd[sd + 1] !== void 0;
					roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
					xd.length = sd;
					if (roundUp) for (; ++xd[--sd] > base - 1;) {
						xd[sd] = 0;
						if (!sd) {
							++e;
							xd.unshift(1);
						}
					}
					for (len = xd.length; !xd[len - 1]; --len);
					for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
					if (isExp) {
						if (len > 1) if (baseOut == 16 || baseOut == 8) {
							i = baseOut == 16 ? 4 : 3;
							for (--len; len % i; len++) str += "0";
							xd = convertBase(str, base, baseOut);
							for (len = xd.length; !xd[len - 1]; --len);
							for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
						} else str = str.charAt(0) + "." + str.slice(1);
						str = str + (e < 0 ? "p" : "p+") + e;
					} else if (e < 0) {
						for (; ++e;) str = "0" + str;
						str = "0." + str;
					} else if (++e > len) for (e -= len; e--;) str += "0";
					else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
				}
				str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
			}
			return x.s < 0 ? "-" + str : str;
		}
		function truncate(arr, len) {
			if (arr.length > len) {
				arr.length = len;
				return true;
			}
		}
		function abs(x) {
			return new this(x).abs();
		}
		function acos(x) {
			return new this(x).acos();
		}
		function acosh(x) {
			return new this(x).acosh();
		}
		function add(x, y) {
			return new this(x).plus(y);
		}
		function asin(x) {
			return new this(x).asin();
		}
		function asinh(x) {
			return new this(x).asinh();
		}
		function atan(x) {
			return new this(x).atan();
		}
		function atanh(x) {
			return new this(x).atanh();
		}
		function atan2(y, x) {
			y = new this(y);
			x = new this(x);
			var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
			if (!y.s || !x.s) r = new this(NaN);
			else if (!y.d && !x.d) {
				r = getPi(this, wpr, 1).times(x.s > 0 ? .25 : .75);
				r.s = y.s;
			} else if (!x.d || y.isZero()) {
				r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
				r.s = y.s;
			} else if (!y.d || x.isZero()) {
				r = getPi(this, wpr, 1).times(.5);
				r.s = y.s;
			} else if (x.s < 0) {
				this.precision = wpr;
				this.rounding = 1;
				r = this.atan(divide(y, x, wpr, 1));
				x = getPi(this, wpr, 1);
				this.precision = pr;
				this.rounding = rm;
				r = y.s < 0 ? r.minus(x) : r.plus(x);
			} else r = this.atan(divide(y, x, wpr, 1));
			return r;
		}
		function cbrt(x) {
			return new this(x).cbrt();
		}
		function ceil(x) {
			return finalise(x = new this(x), x.e + 1, 2);
		}
		function clamp(x, min$1, max$1) {
			return new this(x).clamp(min$1, max$1);
		}
		function config(obj) {
			if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
			var i, p, v, useDefaults = obj.defaults === true, ps = [
				"precision",
				1,
				MAX_DIGITS,
				"rounding",
				0,
				8,
				"toExpNeg",
				-EXP_LIMIT,
				0,
				"toExpPos",
				0,
				EXP_LIMIT,
				"maxE",
				0,
				EXP_LIMIT,
				"minE",
				-EXP_LIMIT,
				0,
				"modulo",
				0,
				9
			];
			for (i = 0; i < ps.length; i += 3) {
				if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
				if ((v = obj[p]) !== void 0) if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
				else throw Error(invalidArgument + p + ": " + v);
			}
			if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
			if ((v = obj[p]) !== void 0) if (v === true || v === false || v === 0 || v === 1) if (v) if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) this[p] = true;
			else throw Error(cryptoUnavailable);
			else this[p] = false;
			else throw Error(invalidArgument + p + ": " + v);
			return this;
		}
		function cos(x) {
			return new this(x).cos();
		}
		function cosh(x) {
			return new this(x).cosh();
		}
		function clone(obj) {
			var i, p, ps;
			function Decimal$1(v) {
				var e, i$1, t, x = this;
				if (!(x instanceof Decimal$1)) return new Decimal$1(v);
				x.constructor = Decimal$1;
				if (isDecimalInstance(v)) {
					x.s = v.s;
					if (external) if (!v.d || v.e > Decimal$1.maxE) {
						x.e = NaN;
						x.d = null;
					} else if (v.e < Decimal$1.minE) {
						x.e = 0;
						x.d = [0];
					} else {
						x.e = v.e;
						x.d = v.d.slice();
					}
					else {
						x.e = v.e;
						x.d = v.d ? v.d.slice() : v.d;
					}
					return;
				}
				t = typeof v;
				if (t === "number") {
					if (v === 0) {
						x.s = 1 / v < 0 ? -1 : 1;
						x.e = 0;
						x.d = [0];
						return;
					}
					if (v < 0) {
						v = -v;
						x.s = -1;
					} else x.s = 1;
					if (v === ~~v && v < 1e7) {
						for (e = 0, i$1 = v; i$1 >= 10; i$1 /= 10) e++;
						if (external) if (e > Decimal$1.maxE) {
							x.e = NaN;
							x.d = null;
						} else if (e < Decimal$1.minE) {
							x.e = 0;
							x.d = [0];
						} else {
							x.e = e;
							x.d = [v];
						}
						else {
							x.e = e;
							x.d = [v];
						}
						return;
					}
					if (v * 0 !== 0) {
						if (!v) x.s = NaN;
						x.e = NaN;
						x.d = null;
						return;
					}
					return parseDecimal(x, v.toString());
				}
				if (t === "string") {
					if ((i$1 = v.charCodeAt(0)) === 45) {
						v = v.slice(1);
						x.s = -1;
					} else {
						if (i$1 === 43) v = v.slice(1);
						x.s = 1;
					}
					return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
				}
				if (t === "bigint") {
					if (v < 0) {
						v = -v;
						x.s = -1;
					} else x.s = 1;
					return parseDecimal(x, v.toString());
				}
				throw Error(invalidArgument + v);
			}
			Decimal$1.prototype = P;
			Decimal$1.ROUND_UP = 0;
			Decimal$1.ROUND_DOWN = 1;
			Decimal$1.ROUND_CEIL = 2;
			Decimal$1.ROUND_FLOOR = 3;
			Decimal$1.ROUND_HALF_UP = 4;
			Decimal$1.ROUND_HALF_DOWN = 5;
			Decimal$1.ROUND_HALF_EVEN = 6;
			Decimal$1.ROUND_HALF_CEIL = 7;
			Decimal$1.ROUND_HALF_FLOOR = 8;
			Decimal$1.EUCLID = 9;
			Decimal$1.config = Decimal$1.set = config;
			Decimal$1.clone = clone;
			Decimal$1.isDecimal = isDecimalInstance;
			Decimal$1.abs = abs;
			Decimal$1.acos = acos;
			Decimal$1.acosh = acosh;
			Decimal$1.add = add;
			Decimal$1.asin = asin;
			Decimal$1.asinh = asinh;
			Decimal$1.atan = atan;
			Decimal$1.atanh = atanh;
			Decimal$1.atan2 = atan2;
			Decimal$1.cbrt = cbrt;
			Decimal$1.ceil = ceil;
			Decimal$1.clamp = clamp;
			Decimal$1.cos = cos;
			Decimal$1.cosh = cosh;
			Decimal$1.div = div;
			Decimal$1.exp = exp;
			Decimal$1.floor = floor;
			Decimal$1.hypot = hypot;
			Decimal$1.ln = ln;
			Decimal$1.log = log;
			Decimal$1.log10 = log10;
			Decimal$1.log2 = log2;
			Decimal$1.max = max;
			Decimal$1.min = min;
			Decimal$1.mod = mod;
			Decimal$1.mul = mul;
			Decimal$1.pow = pow;
			Decimal$1.random = random;
			Decimal$1.round = round;
			Decimal$1.sign = sign;
			Decimal$1.sin = sin;
			Decimal$1.sinh = sinh;
			Decimal$1.sqrt = sqrt;
			Decimal$1.sub = sub;
			Decimal$1.sum = sum;
			Decimal$1.tan = tan;
			Decimal$1.tanh = tanh;
			Decimal$1.trunc = trunc;
			if (obj === void 0) obj = {};
			if (obj) {
				if (obj.defaults !== true) {
					ps = [
						"precision",
						"rounding",
						"toExpNeg",
						"toExpPos",
						"maxE",
						"minE",
						"modulo",
						"crypto"
					];
					for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
				}
			}
			Decimal$1.config(obj);
			return Decimal$1;
		}
		function div(x, y) {
			return new this(x).div(y);
		}
		function exp(x) {
			return new this(x).exp();
		}
		function floor(x) {
			return finalise(x = new this(x), x.e + 1, 3);
		}
		function hypot() {
			var i, n, t = new this(0);
			external = false;
			for (i = 0; i < arguments.length;) {
				n = new this(arguments[i++]);
				if (!n.d) {
					if (n.s) {
						external = true;
						return new this(Infinity);
					}
					t = n;
				} else if (t.d) t = t.plus(n.times(n));
			}
			external = true;
			return t.sqrt();
		}
		function isDecimalInstance(obj) {
			return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
		}
		function ln(x) {
			return new this(x).ln();
		}
		function log(x, y) {
			return new this(x).log(y);
		}
		function log2(x) {
			return new this(x).log(2);
		}
		function log10(x) {
			return new this(x).log(10);
		}
		function max() {
			return maxOrMin(this, arguments, -1);
		}
		function min() {
			return maxOrMin(this, arguments, 1);
		}
		function mod(x, y) {
			return new this(x).mod(y);
		}
		function mul(x, y) {
			return new this(x).mul(y);
		}
		function pow(x, y) {
			return new this(x).pow(y);
		}
		function random(sd) {
			var d, e, k, n, i = 0, r = new this(1), rd = [];
			if (sd === void 0) sd = this.precision;
			else checkInt32(sd, 1, MAX_DIGITS);
			k = Math.ceil(sd / LOG_BASE);
			if (!this.crypto) for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;
			else if (crypto.getRandomValues) {
				d = crypto.getRandomValues(new Uint32Array(k));
				for (; i < k;) {
					n = d[i];
					if (n >= 429e7) d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
					else rd[i++] = n % 1e7;
				}
			} else if (crypto.randomBytes) {
				d = crypto.randomBytes(k *= 4);
				for (; i < k;) {
					n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
					if (n >= 214e7) crypto.randomBytes(4).copy(d, i);
					else {
						rd.push(n % 1e7);
						i += 4;
					}
				}
				i = k / 4;
			} else throw Error(cryptoUnavailable);
			k = rd[--i];
			sd %= LOG_BASE;
			if (k && sd) {
				n = mathpow(10, LOG_BASE - sd);
				rd[i] = (k / n | 0) * n;
			}
			for (; rd[i] === 0; i--) rd.pop();
			if (i < 0) {
				e = 0;
				rd = [0];
			} else {
				e = -1;
				for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
				for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
				if (k < LOG_BASE) e -= LOG_BASE - k;
			}
			r.e = e;
			r.d = rd;
			return r;
		}
		function round(x) {
			return finalise(x = new this(x), x.e + 1, this.rounding);
		}
		function sign(x) {
			x = new this(x);
			return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
		}
		function sin(x) {
			return new this(x).sin();
		}
		function sinh(x) {
			return new this(x).sinh();
		}
		function sqrt(x) {
			return new this(x).sqrt();
		}
		function sub(x, y) {
			return new this(x).sub(y);
		}
		function sum() {
			var i = 0, args = arguments, x = new this(args[i]);
			external = false;
			for (; x.s && ++i < args.length;) x = x.plus(args[i]);
			external = true;
			return finalise(x, this.precision, this.rounding);
		}
		function tan(x) {
			return new this(x).tan();
		}
		function tanh(x) {
			return new this(x).tanh();
		}
		function trunc(x) {
			return finalise(x = new this(x), x.e + 1, 1);
		}
		Decimal = clone(DEFAULTS);
		Decimal.prototype.constructor = Decimal;
		Decimal["default"] = Decimal.Decimal = Decimal;
		LN10 = new Decimal(LN10);
		PI = new Decimal(PI);
		if (typeof define == "function" && define.amd) define(function() {
			return Decimal;
		});
		else if (typeof module != "undefined" && module.exports) {
			if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
				P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
				P[Symbol.toStringTag] = "Decimal";
			}
			module.exports = Decimal;
		} else {
			if (!globalScope) globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
			noConflict = globalScope.Decimal;
			Decimal.noConflict = function() {
				globalScope.Decimal = noConflict;
				return Decimal;
			};
			globalScope.Decimal = Decimal;
		}
	})(exports);
}) });

//#endregion
//#region .temp/utils/type.js
var require_type = /* @__PURE__ */ __commonJS({ ".temp/utils/type.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.isObject = exports.isString = exports.isNumber = void 0;
	const isNumber = (value) => {
		try {
			return Number(value) === value;
		} catch {
			return false;
		}
	};
	exports.isNumber = isNumber;
	const isString = (value) => {
		return typeof value === "string";
	};
	exports.isString = isString;
	const isObject = (value) => {
		return !!value && value.constructor === Object;
	};
	exports.isObject = isObject;
}) });

//#endregion
//#region .temp/utils/string.js
var require_string = /* @__PURE__ */ __commonJS({ ".temp/utils/string.js": ((exports) => {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getDecimalPlaces = void 0;
	const getDecimalPlaces = (num) => {
		const numString = Number(num).toString();
		if (numString.includes("e-")) return Number(numString.split("e-")?.[1]);
		else {
			const decimalPlaces = num?.toString().split(".")[1]?.length || 0;
			return decimalPlaces <= 2 ? 2 : decimalPlaces;
		}
	};
	exports.getDecimalPlaces = getDecimalPlaces;
}) });

//#endregion
//#region .temp/main.js
var require_main = /* @__PURE__ */ __commonJS({ ".temp/main.js": ((exports) => {
	var __importDefault = exports && exports.__importDefault || function(mod) {
		return mod && mod.__esModule ? mod : { "default": mod };
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.CalcInst = exports.Calculator = void 0;
	const decimal_js_1 = __importDefault(require_decimal());
	const type_1 = require_type();
	const string_1 = require_string();
	const defaultUserOptions = {
		keepParamsMaxPrecision: true,
		outputDecimalPlaces: -1,
		taxRate: .1,
		rateType: "INCL"
	};
	Object.seal(defaultUserOptions);
	const defaultDecimalConfigs = {
		precision: 16,
		rounding: decimal_js_1.default.ROUND_HALF_UP,
		toExpNeg: -7,
		toExpPos: 21,
		maxE: 9e15,
		minE: -9e15,
		modulo: 1,
		crypto: false
	};
	Object.seal(defaultDecimalConfigs);
	const cacheFnList = [
		"all",
		"sum",
		"subtractMultiple",
		"calcUnitPrice",
		"calcLinePrice",
		"percentToDecimal",
		"decimalToPercent",
		"calculateDiscountedPrice",
		"computeRate"
	];
	var Calculator = class Calculator {
		constructor() {
			this.calcCache = {
				sum: /* @__PURE__ */ new Map(),
				subtractMultiple: /* @__PURE__ */ new Map(),
				calcUnitPrice: /* @__PURE__ */ new Map(),
				calcLinePrice: /* @__PURE__ */ new Map(),
				percentToDecimal: /* @__PURE__ */ new Map(),
				decimalToPercent: /* @__PURE__ */ new Map(),
				calculateDiscountedPrice: /* @__PURE__ */ new Map(),
				computeRate: /* @__PURE__ */ new Map()
			};
			this.userOptions = { ...defaultUserOptions };
			this.calcConfigs = { ...defaultDecimalConfigs };
		}
		resetInstance() {
			this.clearCache();
			this.userOptions = { ...defaultUserOptions };
			this.calcConfigs = { ...defaultDecimalConfigs };
		}
		setUserOption(option, value) {
			switch (option) {
				case "keepParamsMaxPrecision":
					if (typeof value !== "boolean") throw new Error("参数 keepParamsMaxPrecision 应该为 Boolean 值");
					this.userOptions.keepParamsMaxPrecision = value;
					break;
				case "outputDecimalPlaces":
					if (typeof value !== "number" || value > 16 || value < 0 && value !== -1) throw new Error("参数 outputDecimalPlaces 应该为 [0, 16] 间的数字，或者 -1 表示不进行四舍五入直接返回原始值");
					this.userOptions.outputDecimalPlaces = value;
					break;
				case "taxRate":
					if (typeof value !== "number" || value < 0 || value > 1) throw new Error("参数 taxRate 应该为 [0, 1] 间的数字");
					this.userOptions.taxRate = value;
					break;
				case "rateType": {
					const validRateTypes = [
						"EXCL",
						"INCL",
						"FREE"
					];
					if (!validRateTypes.includes(value)) throw new Error(`请传入正确的 RateType 类型，应该为 'EXCL', 'INCL', 'FREE' 之一`);
					this.userOptions.rateType = value;
					break;
				}
				default: throw new Error(`配置项错误 ${option} , 请检查后重试`);
			}
		}
		_getCalcConfigs() {
			return this.calcConfigs;
		}
		_getUserOptions() {
			return this.userOptions;
		}
		getThisDataMaxPrecision(dataStructure) {
			const curUserOptions = this._getUserOptions();
			const defaultPlaces = curUserOptions.keepParamsMaxPrecision ? -1 : curUserOptions.outputDecimalPlaces;
			if (Array.isArray(dataStructure)) return Math.max(...dataStructure.map((v) => (0, string_1.getDecimalPlaces)(v)));
			else if (typeof dataStructure === "object" && dataStructure !== null) return Math.max(...Object.values(dataStructure).map((v) => (0, string_1.getDecimalPlaces)(v)));
			else if (typeof dataStructure === "number") if (dataStructure % 1 !== 0) return (0, string_1.getDecimalPlaces)(dataStructure);
			else return defaultPlaces;
			return defaultPlaces;
		}
		getCache(cacheType) {
			if (cacheType === null || cacheType === void 0) return this.calcCache;
			if (cacheFnList.includes(cacheType)) return this.calcCache[cacheType];
			else console.warn(`Invalid cacheType: ${cacheType}`);
			return this.calcCache;
		}
		static getInstance() {
			if (!Calculator.instance) Calculator.instance = new Calculator();
			return Calculator.instance;
		}
		clearCache(cacheType = "all") {
			if (!cacheType) throw new Error("cacheType is required");
			if (cacheType === "all" || cacheType === "sum") this.calcCache.sum.clear();
			if (cacheType === "all" || cacheType === "subtractMultiple") this.calcCache.subtractMultiple.clear();
			if (cacheType === "all" || cacheType === "calcUnitPrice") this.calcCache.calcUnitPrice.clear();
			if (cacheType === "all" || cacheType === "calcLinePrice") this.calcCache.calcLinePrice.clear();
			if (cacheType === "all" || cacheType === "percentToDecimal") this.calcCache.percentToDecimal.clear();
			if (cacheType === "all" || cacheType === "decimalToPercent") this.calcCache.decimalToPercent.clear();
			if (cacheType === "all" || cacheType === "calculateDiscountedPrice") this.calcCache.calculateDiscountedPrice.clear();
			if (cacheType === "all" || cacheType === "computeRate") this.calcCache.computeRate.clear();
			if (!cacheFnList.includes(cacheType)) console.warn(`Invalid cacheType: ${cacheType}`);
		}
		queryCacheStat(cacheType = "all") {
			const cacheGroups = {
				sum: this.calcCache.sum,
				subtractMultiple: this.calcCache.subtractMultiple,
				calcUnitPrice: this.calcCache.calcUnitPrice,
				calcLinePrice: this.calcCache.calcLinePrice,
				percentToDecimal: this.calcCache.percentToDecimal,
				decimalToPercent: this.calcCache.decimalToPercent,
				calculateDiscountedPrice: this.calcCache.calculateDiscountedPrice,
				computeRate: this.calcCache.computeRate
			};
			const result = {
				all: 0,
				sum: 0,
				subtractMultiple: 0,
				calcUnitPrice: 0,
				calcLinePrice: 0,
				percentToDecimal: 0,
				decimalToPercent: 0,
				calculateDiscountedPrice: 0,
				computeRate: 0
			};
			const cacheKeys = cacheType === "all" ? Object.keys(cacheGroups) : [cacheType];
			cacheKeys.forEach((key) => {
				if (cacheGroups[key]) {
					result[key] = cacheGroups[key].size;
					result.all += cacheGroups[key].size;
				}
			});
			return result;
		}
		generateCacheKey(data) {
			const stableStringify = (obj) => {
				if (obj === null || obj === void 0) return JSON.stringify(obj);
				if (!(0, type_1.isObject)(obj)) return JSON.stringify(obj);
				if (Array.isArray(obj)) return `[${obj.map(stableStringify).join(",")}]`;
				const sortedKeys = Object.keys(obj).sort();
				const pairs = sortedKeys.map((key) => {
					return `${JSON.stringify(key)}:${stableStringify(obj[key])}`;
				});
				return `{${pairs.join(",")}}`;
			};
			return stableStringify(data);
		}
		sum(data, userOptions) {
			const mergedOptions = { ...this._getUserOptions() };
			if (mergedOptions !== null && (0, type_1.isObject)(userOptions) && Object.keys(userOptions).length > 0) Object.entries(userOptions).forEach(([key, val]) => {
				if (key in this.userOptions) mergedOptions[key] = val;
			});
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				data,
				mergedOptions
			});
			if (this.calcCache.sum.has(cacheKey)) return this.calcCache.sum.get(cacheKey);
			let total = 0;
			let numbersToSum = [];
			if (Array.isArray(data)) numbersToSum = data.filter((num) => (0, type_1.isNumber)(num) && !Number.isNaN(num));
			else if ((0, type_1.isObject)(data)) numbersToSum = Object.values(data).filter((value) => (0, type_1.isNumber)(value) && !Number.isNaN(value));
			else if ((0, type_1.isNumber)(data)) numbersToSum = [data];
			if (numbersToSum.length > 0) {
				let totalDecimal = new DecimalClone(0);
				for (const num of numbersToSum) totalDecimal = totalDecimal.add(new DecimalClone(num));
				const finalDigitNumber = mergedOptions.outputDecimalPlaces === -1 ? -1 : mergedOptions.outputDecimalPlaces;
				total = finalDigitNumber === -1 ? totalDecimal.toNumber() : totalDecimal.toDP(finalDigitNumber).toNumber();
			}
			this.calcCache.sum.set(cacheKey, total);
			return total;
		}
		subtractMultiple(initialValue, subtractValues, userOptions) {
			const mergedOptions = { ...this._getUserOptions() };
			if (mergedOptions !== null && (0, type_1.isObject)(userOptions) && Object.keys(userOptions).length > 0) Object.entries(userOptions).forEach(([key, val]) => {
				if (key in mergedOptions) mergedOptions[key] = val;
			});
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				initialValue,
				subtractValues,
				mergedOptions
			});
			if (!(0, type_1.isNumber)(initialValue) || Number.isNaN(initialValue)) initialValue = 0;
			if (!Array.isArray(subtractValues)) subtractValues = [subtractValues];
			const filteredSubtractValues = subtractValues.filter((v) => (0, type_1.isNumber)(v));
			if (this.calcCache.subtractMultiple.has(cacheKey)) return this.calcCache.subtractMultiple.get(cacheKey);
			let totalDecimal = new DecimalClone(initialValue);
			for (const num of filteredSubtractValues) totalDecimal = totalDecimal.minus(new DecimalClone(num));
			const finalDigitNumber = mergedOptions.outputDecimalPlaces === -1 ? -1 : mergedOptions.outputDecimalPlaces;
			const total = finalDigitNumber === -1 ? totalDecimal.toNumber() : totalDecimal.toDP(finalDigitNumber).toNumber();
			this.calcCache.subtractMultiple.set(cacheKey, total);
			return total;
		}
		calcUnitPrice(calcBaseTotalParams, userOptions) {
			const { quantity, linePrice } = calcBaseTotalParams;
			let finalUnitPrice = null;
			if (quantity === null && linePrice === null) return {
				quantity: null,
				unitPrice: null,
				linePrice: null
			};
			if (quantity === null) return {
				quantity,
				unitPrice: linePrice,
				linePrice
			};
			if (linePrice === null) return {
				quantity,
				unitPrice: null,
				linePrice: null
			};
			if (quantity === 0) return {
				quantity: 0,
				unitPrice: linePrice,
				linePrice
			};
			const mergedOptions = { ...this._getUserOptions() };
			if (mergedOptions !== null && (0, type_1.isObject)(userOptions) && Object.keys(userOptions).length > 0) Object.entries(userOptions).forEach(([key, val]) => {
				if (key in this.userOptions) mergedOptions[key] = val;
			});
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				calcBaseTotalParams,
				mergedOptions
			});
			if (this.calcCache.calcUnitPrice.has(cacheKey)) return this.calcCache.calcUnitPrice.get(cacheKey);
			const quantityDecimal = new DecimalClone(quantity);
			const linePriceDecimal = new DecimalClone(linePrice);
			const unitPriceDecimal = linePriceDecimal.dividedBy(quantityDecimal);
			const finalDigitNumber = mergedOptions.outputDecimalPlaces === -1 ? -1 : mergedOptions.outputDecimalPlaces;
			finalUnitPrice = finalDigitNumber === -1 ? unitPriceDecimal.toNumber() : unitPriceDecimal.toDP(finalDigitNumber).toNumber();
			const result = {
				quantity,
				unitPrice: finalUnitPrice,
				linePrice
			};
			this.calcCache.calcUnitPrice.set(cacheKey, result);
			return result;
		}
		calcLinePrice(calcBaseTotalParams, userOptions) {
			let { quantity, unitPrice } = calcBaseTotalParams;
			let finalLinePrice = 0;
			if (!(0, type_1.isNumber)(quantity) || Number.isNaN(quantity)) quantity = null;
			if (!(0, type_1.isNumber)(unitPrice) || Number.isNaN(unitPrice)) unitPrice = null;
			if ((0, type_1.isNumber)(quantity) && quantity <= 0) {
				console.warn("参数错误, quantity 必须大于等于 0。这里按 0 处理来处理");
				quantity = 0;
			}
			if (quantity === null && (0, type_1.isNumber)(unitPrice) && unitPrice >= 0) return {
				quantity,
				unitPrice,
				linePrice: unitPrice
			};
			if ((0, type_1.isNumber)(quantity) && quantity >= 0 && unitPrice === null) return {
				quantity,
				unitPrice: null,
				linePrice: null
			};
			if (quantity === null && unitPrice === null) return {
				quantity,
				unitPrice: null,
				linePrice: null
			};
			const mergedOptions = { ...this._getUserOptions() };
			if (mergedOptions !== null && (0, type_1.isObject)(userOptions) && Object.keys(userOptions).length > 0) Object.entries(userOptions).forEach(([key, val]) => {
				if (key in this.userOptions) mergedOptions[key] = val;
			});
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				calcBaseTotalParams,
				mergedOptions
			});
			if (this.calcCache.calcLinePrice.has(cacheKey)) return this.calcCache.calcLinePrice.get(cacheKey);
			const quantityDecimal = new DecimalClone(quantity || 0);
			const unitPriceDecimal = new DecimalClone(unitPrice || 0);
			const linePriceDecimal = quantityDecimal.mul(unitPriceDecimal);
			const finalDigitNumber = mergedOptions.outputDecimalPlaces === -1 ? -1 : mergedOptions.outputDecimalPlaces;
			finalLinePrice = finalDigitNumber === -1 ? linePriceDecimal.toNumber() : linePriceDecimal.toDP(finalDigitNumber).toNumber();
			const result = {
				quantity,
				unitPrice,
				linePrice: finalLinePrice
			};
			this.calcCache.calcLinePrice.set(cacheKey, result);
			return result;
		}
		calculateDiscountedPrice(originalPrice, discountRate, userOptions) {
			if (originalPrice === null || discountRate === null || !(0, type_1.isNumber)(originalPrice) || Number.isNaN(originalPrice) || !(0, type_1.isNumber)(discountRate) || Number.isNaN(discountRate)) return null;
			if ((0, type_1.isNumber)(originalPrice) && originalPrice < 0) {
				console.error("参数 originalPrice 应该为大于 0 的数值");
				return originalPrice;
			}
			if (discountRate === 0) return originalPrice;
			if (discountRate === 1) return 0;
			if ((0, type_1.isNumber)(discountRate) && discountRate < 0) {
				console.error("请确保传参 discountRate(折扣率) 在 [0, 1] 之间。 若确认传入是百分比，你可以先使用 percentToDecimal 方法将百分比转换为小数再进行计算。");
				return originalPrice;
			}
			const mergedOptions = { ...this._getUserOptions() };
			if (mergedOptions !== null && (0, type_1.isObject)(userOptions) && Object.keys(userOptions).length > 0) Object.entries(userOptions).forEach(([key, val]) => {
				if (key in this.userOptions) mergedOptions[key] = val;
			});
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				originalPrice,
				discountRate,
				mergedOptions
			});
			if (this.calcCache.calculateDiscountedPrice.has(cacheKey)) return this.calcCache.calculateDiscountedPrice.get(cacheKey);
			const originDecimal = new DecimalClone(originalPrice);
			const finalDigitNumber = mergedOptions.outputDecimalPlaces === -1 ? -1 : mergedOptions.outputDecimalPlaces;
			const ratePrice = originDecimal.mul(discountRate);
			const finalDiscountedPrice = finalDigitNumber === -1 ? originDecimal.sub(ratePrice).toNumber() : originDecimal.sub(ratePrice).toDP(finalDigitNumber).toNumber();
			this.calcCache.calculateDiscountedPrice.set(cacheKey, finalDiscountedPrice);
			return finalDiscountedPrice;
		}
		percentToDecimal(originPercentage, userOptions) {
			const curUserOptions = { ...this._getUserOptions() };
			if (userOptions === void 0) userOptions = curUserOptions;
			else if (!(0, type_1.isObject)(userOptions) && !(0, type_1.isNumber)(userOptions)) userOptions = curUserOptions;
			else if ((0, type_1.isNumber)(userOptions)) {
				const tempNum = Number.isNaN(userOptions) ? userOptions : -1;
				userOptions = { outputDecimalPlaces: tempNum };
			}
			if ((0, type_1.isObject)(userOptions)) Object.entries(userOptions).forEach(([key, val]) => {
				curUserOptions[key] = val;
			});
			if (originPercentage === null || !(0, type_1.isNumber)(originPercentage) || Number.isNaN(originPercentage)) return null;
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const cacheKey = this.generateCacheKey({
				originPercentage,
				curUserOptions
			});
			if (this.calcCache.percentToDecimal?.has(cacheKey)) return this.calcCache.percentToDecimal.get(cacheKey);
			const percentageDecimal = new DecimalClone(originPercentage);
			const hundredDecimal = new DecimalClone(100);
			const resultDecimal = percentageDecimal.dividedBy(hundredDecimal);
			const finalDigitNumber = curUserOptions.outputDecimalPlaces === -1 ? -1 : curUserOptions.outputDecimalPlaces;
			const result = finalDigitNumber === -1 ? resultDecimal.toNumber() : resultDecimal.toDP(finalDigitNumber).toNumber();
			this.calcCache.percentToDecimal.set(cacheKey, result);
			return result;
		}
		decimalToPercent(originNumber, userOptions) {
			const curUserOptions = { ...this._getUserOptions() };
			if (userOptions === void 0) userOptions = curUserOptions;
			else if (!(0, type_1.isObject)(userOptions) && !(0, type_1.isNumber)(userOptions)) {
				console.error("非法参数 userOptions, 请传入正确的参数，第二个参数应该为 0 - 10位 Number 类型, 非法参数按预设处理");
				userOptions = curUserOptions;
			} else if ((0, type_1.isNumber)(userOptions)) {
				const tempNum = userOptions > -1 ? userOptions : -1;
				userOptions = { outputDecimalPlaces: tempNum };
			}
			if ((0, type_1.isObject)(userOptions)) Object.entries(userOptions).forEach(([key, val]) => {
				curUserOptions[key] = val;
			});
			if (originNumber === null || originNumber === 0 || !(0, type_1.isNumber)(originNumber) || Number.isNaN(originNumber)) return 0;
			if (!(0, type_1.isNumber)(userOptions?.outputDecimalPlaces) || Number.isNaN(userOptions?.outputDecimalPlaces)) {
				console.error("参数错误，请检查传参: \n1. originNumber 应该为 Number 类型；\n2. 第二个参数保留小数位数 应为 0 到 10 之间的数字");
				return originNumber;
			}
			if (userOptions.outputDecimalPlaces > 10) {
				console.error("参数错误，请检查传参: 第二个参数保留小数位数应为 0 到 10 之间的数字, 当前大于 10 当作 10 来处理");
				userOptions.outputDecimalPlaces = 10;
			}
			const cacheKey = this.generateCacheKey({
				originNumber,
				userOptions
			});
			const cache = this.getCache("decimalToPercent");
			if (cache.has(cacheKey)) return cache.get(cacheKey);
			const finalDigitNumber = userOptions.outputDecimalPlaces === -1 ? -1 : userOptions.outputDecimalPlaces;
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const resultTemp = DecimalClone(originNumber).mul(100);
			const finalResult = finalDigitNumber === -1 ? resultTemp.toNumber() : resultTemp.toDP(userOptions.outputDecimalPlaces).toNumber();
			this.calcCache.decimalToPercent.set(cacheKey, finalResult);
			return finalResult;
		}
		computeRate(originPrice, param2, param3) {
			const args = [
				originPrice,
				param2,
				param3
			].filter((arg) => arg !== void 0);
			const curUserOptions = { ...this._getUserOptions() };
			curUserOptions.rateType;
			let userOptions = {};
			let userRate = curUserOptions.taxRate;
			if (originPrice === null || originPrice === 0 || !(0, type_1.isNumber)(originPrice) || Number.isNaN(originPrice)) return 0;
			if (args.length === 1 && (0, type_1.isNumber)(args[0])) {
				userRate = curUserOptions.taxRate;
				curUserOptions.rateType;
				userOptions = { ...curUserOptions };
			} else if (args.length === 2 && (0, type_1.isNumber)(param2)) {
				userRate = param2;
				curUserOptions.rateType;
				userOptions = {
					...curUserOptions,
					rateType: curUserOptions.rateType,
					taxRate: param2
				};
			} else if (args.length === 2 && (0, type_1.isObject)(param2)) {
				if (param2.taxRate !== void 0) userRate = param2.taxRate;
				if (param2.rateType !== void 0) param2.rateType;
				userOptions = {
					...curUserOptions,
					...param2
				};
			} else if (args.length === 2 && (!(0, type_1.isNumber)(param2) || !(0, type_1.isObject)(param2))) {
				console.error("param2 传参异常。请参考API文档传入正确的配置项");
				return originPrice;
			} else if (args.length === 3 && (0, type_1.isNumber)(param2) && (0, type_1.isString)(param3)) {
				userRate = param2;
				userOptions = {
					...curUserOptions,
					taxRate: param2,
					rateType: param3
				};
			}
			if ((0, type_1.isObject)(userOptions)) Object.entries(userOptions).forEach(([key, val]) => {
				curUserOptions[key] = val;
			});
			const finalDigitNumber = userOptions.outputDecimalPlaces === -1 ? -1 : userOptions.outputDecimalPlaces;
			if (userRate === null || Number.isNaN(userRate) || typeof userRate !== "number") {
				console.warn("参数 Rate 无效，直接返回原始价格");
				return originPrice;
			} else if (userRate < 0) {
				console.warn(`参数 Rate 应大于0。当前参数错误, 使用默认税率 ${curUserOptions.taxRate}`);
				userRate = curUserOptions.taxRate;
			}
			const cacheKey = this.generateCacheKey({
				originPrice,
				userOptions,
				finalDigitNumber
			});
			if (this.calcCache.computeRate.has(cacheKey)) return this.calcCache.computeRate.get(cacheKey);
			const DecimalClone = decimal_js_1.default.clone({ ...defaultDecimalConfigs });
			const addedRate = DecimalClone(1).add(userOptions.taxRate).toNumber();
			const rateCalculators = {
				FREE: () => DecimalClone(0),
				INCL: (price) => DecimalClone(price).div(addedRate).mul(userOptions.taxRate),
				EXCL: (price) => DecimalClone(price).mul(userOptions.taxRate)
			};
			const calculator = rateCalculators[userOptions.rateType];
			if (!calculator) {
				console.error(`参数 ${userOptions.rateType} 类型错误`);
				return originPrice;
			}
			const finalResult = finalDigitNumber === -1 ? calculator(originPrice).toNumber() : calculator(originPrice).toDP(finalDigitNumber).toNumber();
			this.calcCache.computeRate.set(cacheKey, finalResult);
			return finalResult;
		}
	};
	exports.Calculator = Calculator;
	exports.CalcInst = Calculator.getInstance();
}) });

//#endregion
//#region .temp/index.js
Object.defineProperty(exports, "__esModule", { value: true });
exports.CalcInst = void 0;
const main_1 = require_main();
Object.defineProperty(exports, "CalcInst", {
	enumerable: true,
	get: function() {
		return main_1.CalcInst;
	}
});
exports.default = main_1.Calculator;

//#endregion